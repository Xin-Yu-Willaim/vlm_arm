现在遇到的问题：项目1实现的遥控录制回放操作。再录制时候主从臂延时很高。但是项目2的遥控操作没有这个问题。
希望：你帮我参考项目二，改进项目一的遥控录制回放操作。要求：不要项目二中的摄像头部分。加入保留菜单功能，可以输入1-10保存动作类似的机制。改完后给我完整的项目1代码。谢谢

项目1代码：
import json
import numpy as np
import os
import time
import threading
import logging
import traceback
from contextlib import nullcontext
from copy import copy

import cv2
import torch
from termcolor import colored

# 假设这些模块来自 lerobot 项目
from lerobot.common.robot_devices.motors.feetech import FeetechMotorsBus
from lerobot.common.robot_devices.motors.configs import FeetechMotorsBusConfig
from lerobot.common.robot_devices.utils import busy_wait
from lerobot.common.utils.utils import get_safe_torch_device

# 语言字典，支持中英文
LANGUAGES = {
    "zh": {
        "welcome": "欢迎使用拖动示教程序，请选择语言：\n1. 中文\n2. 英文\n输入 1 或 2：",
        "invalid_language": "无效的选择，默认使用中文",
        "start_teaching": "开始拖动示教...",
        "bus_connected": "舵机总线连接成功",
        "bus_failed": "舵机总线连接失败: {}",
        "menu": "\n拖动示教 (STS3215版本)\nq: 退出程序\nr: 开始录制动作\nc: 停止录制动作\np: 回放动作\ns: 保存录制动作\nl: 读取本地动作\nm: 放松主臂\nu: 锁定主臂\nn: 放松从臂\nv: 锁定从臂\no: 进入远程遥控模式\nx: 退出远程遥控模式\n----------------------------------",
        "exit": "正在退出程序...",
        "prepare_record": "准备录制动作...",
        "start_record": "开始录制动作",
        "recording": "录制中... 时间: {:.2f}s, 位置: {}",
        "record_end": "录制结束，共记录 {} 个位置点",
        "stop_record": "停止录制动作",
        "thread_warning": "警告：录制线程未及时停止",
        "no_data_edit": "当前没有录制数据",
        "edit_info": "录制数据包含 {} 个位置点",
        "trim_start": "删除前3帧？(y/n): ",
        "trim_end": "删除后3帧？(y/n): ",
        "edit_result": "编辑后剩余 {} 个位置点",
        "prepare_stop": "准备停止录制...",
        "prepare_play": "准备回放动作...",
        "start_play": "开始回放动作",
        "input_action": "请输入要回放的动作编号（1-10）：",
        "input_speed": "请输入回放速度倍率（0.5-2.0，默认1.0）：",
        "action_not_exist": "动作 {} 不存在。",
        "invalid_input": "无效输入，请输入 1 到 10 之间的数字。",
        "play_error": "回放过程中出错: {}",
        "prepare_save": "准备保存动作...",
        "no_data_save": "没有动作数据可保存",
        "input_action_save": "请输入要保存的动作编号（1-10）：",
        "input_name": "请输入动作名称（可选，直接回车跳过）：",
        "action_saved": "动作 {} 已保存。",
        "input_filename_save": "请输入保存文件名（默认 recorded_actions.json）：",
        "save_success": "动作数据已保存到 {}",
        "save_failed": "保存动作数据失败: {}",
        "prepare_load": "准备加载动作...",
        "input_filename_load": "请输入加载文件名（默认 recorded_actions.json）：",
        "load_success": "成功加载动作数据从 {}",
        "load_failed": "加载动作数据失败: {}",
        "file_not_found": "未找到文件 {}",
        "config_failed": "加载配置文件失败: {}，使用默认设置",
        "torque_off_warning": "警告：机械臂扭矩已关闭，请确保安全！",
        "torque_error": "设置扭矩出错: {}",
        "arm_relaxed": "机械臂已放松",
        "arm_locked": "机械臂已锁定",
        "invalid_key": "无效按键 '{}’，请按菜单中的选项操作",
        "interrupt": "程序被用户中断",
        "error": "程序出错: {}",
        "end": "程序结束",
        "master_torque_off": "主臂扭矩关闭，可能下落，请注意安全！",
        "slave_torque_off": "从臂扭矩关闭，可能下落，请注意安全！",
        "master_torque_on": "主臂扭矩开启",
        "slave_torque_on": "从臂扭矩开启",
        "remote_mode_started": "进入远程遥控模式。",
        "remote_mode_stopped": "退出远程遥控模式。",
        "already_in_remote_mode": "已处于远程遥控模式中",
        "not_in_remote_mode": "当前不在远程遥控模式中"
    },
    "en": {
        "welcome": "Welcome to the Drag Teaching Program, please select a language:\n1. Chinese\n2. English\nEnter 1 or 2: ",
        "invalid_language": "Invalid selection, defaulting to Chinese",
        "start_teaching": "Starting drag teaching...",
        "bus_connected": "Motor bus connected successfully",
        "bus_failed": "Motor bus connection failed: {}",
        "menu": "\nDrag Teaching (STS3215 Version)\nq: Quit program\nr: Start recording action\nc: Stop recording action\np: Play back action\ns: Save recorded actions locally\nl: Load recorded actions from local\nm: Relax master arm (disable torque)\nn: Relax slave arm (disable torque)\nu: Lock master arm (enable torque)\nv: Lock slave arm (enable torque)\no: Enter remote teleoperation mode\nx: Exit remote teleoperation mode\n----------------------------------",
        "exit": "Exiting program...",
        "prepare_record": "Preparing to record action...",
        "start_record": "Starting action recording",
        "recording": " Recording... Time: {:.2f}s, Positions: {}",
        "record_end": "Recording ended, total {} position points recorded",
        "stop_record": "Recording stopped",
        "thread_warning": "Warning: Recording thread did not stop in time",
        "no_data_edit": "No recorded data available for editing",
        "edit_info": "Current recording contains {} position points",
        "trim_start": "Remove the first 3 frames? (y/n): ",
        "trim_end": "Remove the last 3 frames? (y/n): ",
        "edit_result": "Remaining {} position points after editing",
        "prepare_stop": "Preparing to stop recording...",
        "prepare_play": "Preparing to play back action...",
        "start_play": "Starting action playback",
        "input_action": "Enter the action number to play back (1-10): ",
        "input_speed": "Enter playback speed factor (0.5-2.0, default 1.0): ",
        "action_not_exist": "Action {} does not exist.",
        "invalid_input": "Invalid input, please enter a number between 1 and 10.",
        "play_error": "Error during playback: {}",
        "prepare_save": "Preparing to save action...",
        "no_data_save": "No action data available to save",
        "input_action_save": "Enter the action number to save (1-10): ",
        "input_name": "Enter action name (optional, press Enter to skip): ",
        "action_saved": "Action {} saved.",
        "input_filename_save": "Enter save filename (default recorded_actions.json): ",
        "save_success": "Action data saved to {}",
        "save_failed": "Failed to save action data: {}",
        "prepare_load": "Preparing to load action...",
        "input_filename_load": "Enter load filename (default recorded_actions.json): ",
        "load_success": "Successfully loaded action data from {}",
        "load_failed": "Failed to load action data: {}",
        "file_not_found": "File {} not found",
        "config_failed": "Failed to load config: {}, using defaults",
        "torque_off_warning": "Warning: Arm torque disabled, ensure safety!",
        "torque_error": "Error setting torque: {}",
        "arm_relaxed": "Arm relaxed",
        "arm_locked": "Arm locked",
        "invalid_key": "Invalid key '{}', please use options from the menu",
        "interrupt": "Program interrupted by user",
        "error": "Program error: {}",
        "end": "Program ended",
        "master_torque_off": "Master arm torque disabled, ensure safety!",
        "slave_torque_off": "Slave arm torque disabled, ensure safety!",
        "master_torque_on": "Master arm torque enabled",
        "slave_torque_on": "Slave arm torque enabled",
        "remote_mode_started": "Entered remote teleoperation mode.",
        "remote_mode_stopped": "Exited remote teleoperation mode.",
        "already_in_remote_mode": "Already in remote teleoperation mode",
        "not_in_remote_mode": "Not in remote teleoperation mode"
    }
}

# 全局变量
current_language = "zh"  # 默认中文
LAST_USED_FILE = "recorded_actions.json"  # 默认保存文件

def select_language():
    """选择语言"""
    global current_language
    print(LANGUAGES["zh"]["welcome"])
    choice = input().strip()
    if choice == "2":
        current_language = "en"
        print("Language set to English")
    elif choice != "1":
        print(LANGUAGES["zh"]["invalid_language"])
    else:
        print("语言设置为中文")

def load_config(config_file="config.json"):
    """加载配置文件"""
    try:
        with open(config_file, "r") as f:
            config = json.load(f)
            if "master" not in config or "slave" not in config:
                raise ValueError("Config must contain 'master' and 'slave' sections")
            return config
    except Exception as e:
        print(LANGUAGES[current_language]["config_failed"].format(e))
        return {
            "master": {"port": "COM5", "baudrate": 1000000, "motor_ids": [1, 2, 3, 4, 5, 6]},
            "slave": {"port": "COM6", "baudrate": 1000000, "motor_ids": [7, 8, 9, 10, 11, 12]},
            "sample_interval": 0.03
        }

def initialize_motors(config):
    """初始化主从臂舵机总线"""
    master_motors = {f"joint_{i+1}": (motor_id, "sts3215") for i, motor_id in enumerate(config["master"]["motor_ids"])}
    master_bus_config = FeetechMotorsBusConfig(port=config["master"]["port"], motors=master_motors, mock=False)
    master_bus = FeetechMotorsBus(master_bus_config)
    try:
        master_bus.connect()
        print(LANGUAGES[current_language]["bus_connected"])
    except Exception as e:
        print(LANGUAGES[current_language]["bus_failed"].format(e))
        raise

    slave_motors = {f"joint_{i+1}": (motor_id, "sts3215") for i, motor_id in enumerate(config["slave"]["motor_ids"])}
    slave_bus_config = FeetechMotorsBusConfig(port=config["slave"]["port"], motors=slave_motors, mock=False)
    slave_bus = FeetechMotorsBus(slave_bus_config)
    try:
        slave_bus.connect()
        print(LANGUAGES[current_language]["bus_connected"])
    except Exception as e:
        print(LANGUAGES[current_language]["bus_failed"].format(e))
        raise

    return master_bus, slave_bus

# 模拟 lerobot 中的 log_control_info 和 busy_wait 使用
def log_control_info(robot_bus, dt_s, fps=None):
    msg = f"dt: {dt_s*1000:.2f} ms ({1/dt_s:.1f} Hz)"
    if fps is not None and (1/dt_s) < fps - 1:
        msg = colored(msg, "yellow")
    logging.info(msg)

# TeachingTest 类：实现录制、回放及远程遥控模式
class TeachingTest:
    def __init__(self, master_bus, slave_bus):
        self.master_bus = master_bus
        self.slave_bus = slave_bus
        self.recording = False
        self.remote_mode = False
        self.remote_thread = None
        self.record_list = {}
        self.current_recording = []
        self.fps = 30  # 默认遥控频率
        self.load_from_local(LAST_USED_FILE)

    def set_master_torque(self, enable):
        try:
            self.master_bus.write("Torque_Enable", enable)
            print(LANGUAGES[current_language]["master_torque_on"] if enable else LANGUAGES[current_language]["master_torque_off"])
        except Exception as e:
            print(LANGUAGES[current_language]["torque_error"].format(e))

    def set_slave_torque(self, enable):
        try:
            self.slave_bus.write("Torque_Enable", enable)
            print(LANGUAGES[current_language]["slave_torque_on"] if enable else LANGUAGES[current_language]["slave_torque_off"])
        except Exception as e:
            print(LANGUAGES[current_language]["torque_error"].format(e))

    def remote_mode_loop(self, fps):
        sample_interval = 1.0 / fps
        start_time = time.perf_counter()
        while self.remote_mode:
            loop_start = time.perf_counter()
            # 读取主臂当前位置信息
            master_positions = self.master_bus.read("Present_Position")
            if master_positions is not None:
                self.slave_bus.write("Goal_Position", master_positions)
            dt = time.perf_counter() - loop_start
            busy_wait(max(0, sample_interval - dt))
            log_control_info(self.master_bus, dt, fps)
        print("\n" + LANGUAGES[current_language]["remote_mode_stopped"])

    def start_remote_mode(self):
        if not self.remote_mode:
            self.remote_mode = True
            # 使用配置的 fps 运行远程模式
            self.remote_thread = threading.Thread(target=self.remote_mode_loop, args=(self.fps,), daemon=True)
            self.remote_thread.start()
            print(LANGUAGES[current_language]["remote_mode_started"])
        else:
            print(LANGUAGES[current_language]["already_in_remote_mode"])

    def stop_remote_mode(self):
        if self.remote_mode:
            self.remote_mode = False
            self.remote_thread.join(timeout=1.0)
            if self.remote_thread.is_alive():
                print(LANGUAGES[current_language]["thread_warning"])
            else:
                print(LANGUAGES[current_language]["remote_mode_stopped"])
        else:
            print(LANGUAGES[current_language]["not_in_remote_mode"])

    def record(self, sample_interval=0.015):
        if self.remote_mode:
            print(LANGUAGES[current_language]["already_in_remote_mode"])
            return
        self.current_recording = []
        self.recording = True
        start_time = time.time()

        def _record():
            last_time = time.time()
            self.slave_bus.write("Acceleration", 50)
            self.slave_bus.write("Goal_Speed", 4000)
            while self.recording:
                now = time.time()
                if now - last_time >= sample_interval:
                    try:
                        master_positions = self.master_bus.read("Present_Position")
                        if master_positions is not None:
                            self.slave_bus.write("Goal_Position", master_positions)
                            self.current_recording.append(master_positions.tolist())
                            print(f"\r{LANGUAGES[current_language]['recording'].format(now - start_time, master_positions)}", end="")
                        last_time = now
                    except Exception as e:
                        print(f"\n{LANGUAGES[current_language]['torque_error'].format(e)}")
                time.sleep(0.001)
            print(f"\n{LANGUAGES[current_language]['record_end'].format(len(self.current_recording))}")

        print(LANGUAGES[current_language]["start_record"])
        self.record_t = threading.Thread(target=_record, daemon=True)
        self.record_t.start()

    def stop_record(self):
        if self.recording:
            self.recording = False
            self.record_t.join(timeout=1.0)
            if self.record_t.is_alive():
                print(LANGUAGES[current_language]["thread_warning"])
            else:
                print(LANGUAGES[current_language]["stop_record"])
            self.edit_recording()

    def edit_recording(self):
        if not self.current_recording:
            print(LANGUAGES[current_language]["no_data_edit"])
            return
        print(LANGUAGES[current_language]["edit_info"].format(len(self.current_recording)))
        trim_start = input(LANGUAGES[current_language]["trim_start"]).lower() == 'y'
        trim_end = input(LANGUAGES[current_language]["trim_end"]).lower() == 'y'
        if trim_start:
            self.current_recording = self.current_recording[3:]
        if trim_end and len(self.current_recording) > 3:
            self.current_recording = self.current_recording[:-3]
        print(LANGUAGES[current_language]["edit_result"].format(len(self.current_recording)))

    def save_recording(self):
        global LAST_USED_FILE
        if not self.current_recording:
            print(LANGUAGES[current_language]["no_data_save"])
            return
        action_number = input(LANGUAGES[current_language]["input_action_save"])
        if action_number.isdigit() and 1 <= int(action_number) <= 10:
            action_number = int(action_number)
            action_name = input(LANGUAGES[current_language]["input_name"])
            self.record_list[action_number] = {
                "positions": self.current_recording.copy(),
                "name": action_name or f"Action_{action_number}",
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            print(LANGUAGES[current_language]["action_saved"].format(action_number))
            filename = input(LANGUAGES[current_language]["input_filename_save"]) or "recorded_actions.json"
            LAST_USED_FILE = filename
            self.save_to_file(filename)
        else:
            print(LANGUAGES[current_language]["invalid_input"])

    def save_to_file(self, filename="recorded_actions.json"):
        try:
            with open(filename, "w") as f:
                json.dump(self.record_list, f, indent=4)
            print(LANGUAGES[current_language]["save_success"].format(filename))
        except Exception as e:
            print(LANGUAGES[current_language]["save_failed"].format(e))

    def load_from_local(self, filename="recorded_actions.json"):
        if os.path.exists(filename):
            try:
                with open(filename, "r") as f:
                    data = json.load(f)
                    converted_data = {int(k): v for k, v in data.items() if "positions" in v}
                    self.record_list = converted_data
                print(LANGUAGES[current_language]["load_success"].format(filename))
            except Exception as e:
                print(LANGUAGES[current_language]["load_failed"].format(e))
        else:
            print(LANGUAGES[current_language]["file_not_found"].format(filename))

    def play(self):
        if self.remote_mode:
            print(LANGUAGES[current_language]["already_in_remote_mode"])
            return
        print(LANGUAGES[current_language]["start_play"])
        action_number = input(LANGUAGES[current_language]["input_action"])
        if action_number.isdigit() and 1 <= int(action_number) <= 10:
            action_number = int(action_number)
            if action_number in self.record_list:
                try:
                    speed_factor = float(input(LANGUAGES[current_language]["input_speed"]) or 1.0)
                except Exception:
                    speed_factor = 1.0
                speed_factor = max(0.5, min(2.0, speed_factor))
                positions_to_play = self.record_list[action_number]["positions"]
                try:
                    self.slave_bus.write("Acceleration", 100)
                    BASE_SPEED = int(8000 * speed_factor)
                    self.slave_bus.write("Goal_Speed", BASE_SPEED)
                    for i in range(len(positions_to_play)-1):
                        start_pos = np.array(positions_to_play[i], dtype=np.int32)
                        end_pos = np.array(positions_to_play[i+1], dtype=np.int32)
                        diff = end_pos - start_pos
                        max_diff = np.max(np.abs(diff))
                        steps = 3 if max_diff < 100 else 5 if max_diff < 300 else 7
                        for pos in self.interpolate_positions(start_pos, end_pos, steps):
                            self.slave_bus.write("Goal_Position", pos)
                            time.sleep(0.03 / speed_factor)
                except Exception as e:
                    print(LANGUAGES[current_language]["play_error"].format(e))
            else:
                print(LANGUAGES[current_language]["action_not_exist"].format(action_number))
        else:
            print(LANGUAGES[current_language]["invalid_input"])

    def interpolate_positions(self, start_pos, end_pos, steps):
        result = []
        for i in range(steps):
            t = i / (steps - 1)
            t = 2 * t * t if t < 0.5 else 1 - ((-2 * t + 2) ** 2) / 2
            pos = start_pos + (end_pos - start_pos) * t
            result.append(np.round(pos).astype(np.int32))
        return result

    def print_menu(self):
        print(LANGUAGES[current_language]["menu"])

    def start(self):
        self.print_menu()
        # 使用 msvcrt 读取键盘（适用于 Windows）
        import msvcrt
        while True:
            if msvcrt.kbhit():
                key = msvcrt.getch().decode('utf-8').lower()
                if key == "q":
                    print(LANGUAGES[current_language]["exit"])
                    break
                elif key == "r":
                    print(LANGUAGES[current_language]["prepare_record"])
                    config = load_config()
                    self.record(config["sample_interval"])
                elif key == "c":
                    print(LANGUAGES[current_language]["prepare_stop"])
                    self.stop_record()
                elif key == "p":
                    print(LANGUAGES[current_language]["prepare_play"])
                    self.play()
                elif key == "s":
                    print(LANGUAGES[current_language]["prepare_save"])
                    self.save_recording()
                elif key == "l":
                    print(LANGUAGES[current_language]["prepare_load"])
                    filename = input(LANGUAGES[current_language]["input_filename_load"]) or LAST_USED_FILE
                    self.load_from_local(filename)
                elif key == "m":
                    self.set_master_torque(0)
                elif key == "n":
                    self.set_slave_torque(0)
                elif key == "u":
                    self.set_master_torque(1)
                elif key == "v":
                    self.set_slave_torque(1)
                elif key == "o":
                    # 启动远程遥控模式
                    self.start_remote_mode()
                elif key == "x":
                    # 退出远程遥控模式
                    self.stop_remote_mode()
                else:
                    print(LANGUAGES[current_language]["invalid_key"].format(key))
        self.master_bus.disconnect()
        self.slave_bus.disconnect()

def drag_teach():
    print(LANGUAGES[current_language]["start_teaching"])
    config = load_config()
    master_bus, slave_bus = initialize_motors(config)
    recorder = TeachingTest(master_bus, slave_bus)
    recorder.start()

if __name__ == '__main__':
    select_language()
    try:
        drag_teach()
    except KeyboardInterrupt:
        print(LANGUAGES[current_language]["interrupt"])
    except Exception as e:
        print(LANGUAGES[current_language]["error"].format(e))
    finally:
        print(LANGUAGES[current_language]["end"])



项目2代码：
"""
Utilities to control a robot.

Useful to record a dataset, replay a recorded episode, run the policy on your robot
and record an evaluation dataset, and to recalibrate your robot if needed.

Examples of usage:

- Recalibrate your robot:
```bash
python control_robot.py  --robot.type=so100  --control.type=calibrate
```

- Unlimited teleoperation at highest frequency (~200 Hz is expected), to exit with CTRL+C:
```bash
python lerobot/scripts/control_robot.py \
    --robot.type=so100 \
    --robot.cameras='{}' \
    --control.type=teleoperate

# Add the cameras from the robot definition to visualize them:
python control_robot.py --robot.type=so100 --robot.cameras='{}' --control.type=teleoperate
```

- Unlimited teleoperation at a limited frequency of 30 Hz, to simulate data recording frequency:
```bash
python lerobot/scripts/control_robot.py \
    --robot.type=so100 \
    --control.type=teleoperate \
    --control.fps=30
```

- Record one episode in order to test replay:
```bash
python lerobot/scripts/control_robot.py  --robot.type=so100 \
    --control.type=record \
    --control.fps=30 \
    --control.single_task="Grasp a lego block and put it in the bin." \
    --control.repo_id=$USER/koch_test \
    --control.num_episodes=1 \
    --control.push_to_hub=True
```

python lerobot/scripts/control_robot.py  --robot.type=so100 \
    --control.type=record \
    --control.fps=30 \
    --control.single_task="Grasp a lego block and put it in the bin." \
    --control.repo_id=$USER/koch_test \
    --control.num_episodes=1 \

- Visualize dataset:
```bash
python lerobot/scripts/visualize_dataset.py \
    --repo-id $USER/koch_test \
    --episode-index 0
```

- Replay this test episode:
```bash
python lerobot/scripts/control_robot.py replay \
    --robot.type=so100 \
    --control.type=replay \
    --control.fps=30 \
    --control.repo_id=$USER/koch_test \
    --control.episode=0
```

- Record a full dataset in order to train a policy, with 2 seconds of warmup,
30 seconds of recording for each episode, and 10 seconds to reset the environment in between episodes:
```bash
python lerobot/scripts/control_robot.py record \
    --robot.type=so100 \
    --control.type=record \
    --control.fps 30 \
    --control.repo_id=$USER/koch_pick_place_lego \
    --control.num_episodes=50 \
    --control.warmup_time_s=2 \
    --control.episode_time_s=30 \
    --control.reset_time_s=10
```

**NOTE**: You can use your keyboard to control data recording flow.
- Tap right arrow key '->' to early exit while recording an episode and go to resseting the environment.
- Tap right arrow key '->' to early exit while resetting the environment and got to recording the next episode.
- Tap left arrow key '<-' to early exit and re-record the current episode.
- Tap escape key 'esc' to stop the data recording.
This might require a sudo permission to allow your terminal to monitor keyboard events.

**NOTE**: You can resume/continue data recording by running the same data recording command and adding `--control.resume=true`.
If the dataset you want to extend is not on the hub, you also need to add `--control.local_files_only=true`.

- Train on this dataset with the ACT policy:
```bash
python lerobot/scripts/train.py \
  --dataset.repo_id=${HF_USER}/koch_pick_place_lego \
  --policy.type=act \
  --output_dir=outputs/train/act_koch_pick_place_lego \
  --job_name=act_koch_pick_place_lego \
  --device=cuda \
  --wandb.enable=true
```

- Run the pretrained policy on the robot:
```bash
python lerobot/scripts/control_robot.py \
    --robot.type=so100 \
    --control.type=record \
    --control.fps=30 \
    --control.single_task="Grasp a lego block and put it in the bin." \
    --control.repo_id=$USER/eval_act_koch_pick_place_lego \
    --control.num_episodes=10 \
    --control.warmup_time_s=2 \
    --control.episode_time_s=30 \
    --control.reset_time_s=10 \
    --control.push_to_hub=true \
    --control.policy.path=outputs/train/act_koch_pick_place_lego/checkpoints/080000/pretrained_model
```
"""

import logging
import time
from dataclasses import asdict
from pprint import pformat

# from safetensors.torch import load_file, save_file
from lerobot.common.datasets.lerobot_dataset import LeRobotDataset
from lerobot.common.policies.factory import make_policy
from lerobot.common.robot_devices.control_configs import (
    CalibrateControlConfig,
    ControlPipelineConfig,
    RecordControlConfig,
    ReplayControlConfig,
    TeleoperateControlConfig,
)
from lerobot.common.robot_devices.control_utils import (
    control_loop,
    init_keyboard_listener,
    log_control_info,
    record_episode,
    reset_environment,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
    stop_recording,
    warmup_record,
)
from lerobot.common.robot_devices.robots.utils import Robot, make_robot_from_config
from lerobot.common.robot_devices.utils import busy_wait, safe_disconnect
from lerobot.common.utils.utils import has_method, init_logging, log_say
from lerobot.configs import parser

########################################################################################
# Control modes
########################################################################################


@safe_disconnect
def calibrate(robot: Robot, cfg: CalibrateControlConfig):
    # TODO(aliberts): move this code in robots' classes
    if robot.robot_type.startswith("stretch"):
        if not robot.is_connected:
            robot.connect()
        if not robot.is_homed():
            robot.home()
        return

    arms = robot.available_arms if cfg.arms is None else cfg.arms
    unknown_arms = [arm_id for arm_id in arms if arm_id not in robot.available_arms]
    available_arms_str = " ".join(robot.available_arms)
    unknown_arms_str = " ".join(unknown_arms)

    if arms is None or len(arms) == 0:
        raise ValueError(
            "No arm provided. Use `--arms` as argument with one or more available arms.\n"
            f"For instance, to recalibrate all arms add: `--arms {available_arms_str}`"
        )

    if len(unknown_arms) > 0:
        raise ValueError(
            f"Unknown arms provided ('{unknown_arms_str}'). Available arms are `{available_arms_str}`."
        )

    for arm_id in arms:
        arm_calib_path = robot.calibration_dir / f"{arm_id}.json"
        if arm_calib_path.exists():
            print(f"Removing '{arm_calib_path}'")
            arm_calib_path.unlink()
        else:
            print(f"Calibration file not found '{arm_calib_path}'")

    if robot.is_connected:
        robot.disconnect()

    # Calling `connect` automatically runs calibration
    # when the calibration file is missing
    robot.connect()
    robot.disconnect()
    print("Calibration is done! You can now teleoperate and record datasets!")


@safe_disconnect
def teleoperate(robot: Robot, cfg: TeleoperateControlConfig):
    control_loop(
        robot,
        control_time_s=cfg.teleop_time_s,
        fps=cfg.fps,
        teleoperate=True,
        display_cameras=cfg.display_cameras,
    )


@safe_disconnect
def record(
    robot: Robot,
    cfg: RecordControlConfig,
) -> LeRobotDataset:
    # TODO(rcadene): Add option to record logs
    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.repo_id,
            root=cfg.root,
            local_files_only=cfg.local_files_only,
        )
        if len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.num_image_writer_processes,
                num_threads=cfg.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.fps, cfg.video)
    else:
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.repo_id,
            cfg.fps,
            root=cfg.root,
            robot=robot,
            use_videos=cfg.video,
            image_writer_processes=cfg.num_image_writer_processes,
            image_writer_threads=cfg.num_image_writer_threads_per_camera * len(robot.cameras),
        )

    # Load pretrained policy
    policy = None if cfg.policy is None else make_policy(cfg.policy, cfg.device, ds_meta=dataset.meta)

    if not robot.is_connected:
        robot.connect()

    listener, events = init_keyboard_listener()

    # Execute a few seconds without recording to:
    # 1. teleoperate the robot to move it in starting position if no policy provided,
    # 2. give times to the robot devices to connect and start synchronizing,
    # 3. place the cameras windows on screen
    enable_teleoperation = policy is None
    log_say("Warmup record", cfg.play_sounds)
    warmup_record(robot, events, enable_teleoperation, cfg.warmup_time_s, cfg.display_cameras, cfg.fps)

    if has_method(robot, "teleop_safety_stop"):
        robot.teleop_safety_stop()

    recorded_episodes = 0
    while True:
        if recorded_episodes >= cfg.num_episodes:
            break

        log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
        record_episode(
            dataset=dataset,
            robot=robot,
            events=events,
            episode_time_s=cfg.episode_time_s,
            display_cameras=cfg.display_cameras,
            policy=policy,
            device=cfg.device,
            use_amp=cfg.use_amp,
            fps=cfg.fps,
        )

        # Execute a few seconds without recording to give time to manually reset the environment
        # Current code logic doesn't allow to teleoperate during this time.
        # TODO(rcadene): add an option to enable teleoperation during reset
        # Skip reset for the last episode to be recorded
        if not events["stop_recording"] and (
            (recorded_episodes < cfg.num_episodes - 1) or events["rerecord_episode"]
        ):
            log_say("Reset the environment", cfg.play_sounds)
            reset_environment(robot, events, cfg.reset_time_s)

        if events["rerecord_episode"]:
            log_say("Re-record episode", cfg.play_sounds)
            events["rerecord_episode"] = False
            events["exit_early"] = False
            dataset.clear_episode_buffer()
            continue

        dataset.save_episode(cfg.single_task)
        recorded_episodes += 1

        if events["stop_recording"]:
            break

    log_say("Stop recording", cfg.play_sounds, blocking=True)
    stop_recording(robot, listener, cfg.display_cameras)

    if cfg.run_compute_stats:
        logging.info("Computing dataset statistics")

    dataset.consolidate(cfg.run_compute_stats)

    if cfg.push_to_hub:
        dataset.push_to_hub(tags=cfg.tags, private=cfg.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


@safe_disconnect
def replay(
    robot: Robot,
    cfg: ReplayControlConfig,
):
    # TODO(rcadene, aliberts): refactor with control_loop, once `dataset` is an instance of LeRobotDataset
    # TODO(rcadene): Add option to record logs

    dataset = LeRobotDataset(
        cfg.repo_id, root=cfg.root, episodes=[cfg.episode], local_files_only=cfg.local_files_only
    )
    actions = dataset.hf_dataset.select_columns("action")

    if not robot.is_connected:
        robot.connect()

    log_say("Replaying episode", cfg.play_sounds, blocking=True)
    for idx in range(dataset.num_frames):
        start_episode_t = time.perf_counter()

        action = actions[idx]["action"]
        robot.send_action(action)

        dt_s = time.perf_counter() - start_episode_t
        busy_wait(1 / cfg.fps - dt_s)

        dt_s = time.perf_counter() - start_episode_t
        log_control_info(robot, dt_s, fps=cfg.fps)


@parser.wrap()
def control_robot(cfg: ControlPipelineConfig):
    init_logging()
    logging.info(pformat(asdict(cfg)))

    robot = make_robot_from_config(cfg.robot)

    if isinstance(cfg.control, CalibrateControlConfig):
        calibrate(robot, cfg.control)
    elif isinstance(cfg.control, TeleoperateControlConfig):
        teleoperate(robot, cfg.control)
    elif isinstance(cfg.control, RecordControlConfig):
        record(robot, cfg.control)
    elif isinstance(cfg.control, ReplayControlConfig):
        replay(robot, cfg.control)

    if robot.is_connected:
        # Disconnect manually to avoid a "Core dump" during process
        # termination due to camera threads not properly exiting.
        robot.disconnect()


if __name__ == "__main__":
    control_robot()



import inspect
import sys
from argparse import ArgumentError
from functools import wraps
from pathlib import Path
from typing import Sequence

import draccus

from lerobot.common.utils.utils import has_method

PATH_KEY = "path"
draccus.set_config_type("json")


def get_cli_overrides(field_name: str, args: Sequence[str] | None = None) -> list[str] | None:
    """Parses arguments from cli at a given nested attribute level.

    For example, supposing the main script was called with:
    python myscript.py --arg1=1 --arg2.subarg1=abc --arg2.subarg2=some/path

    If called during execution of myscript.py, get_cli_overrides("arg2") will return:
    ["--subarg1=abc" "--subarg2=some/path"]
    """
    if args is None:
        args = sys.argv[1:]
    attr_level_args = []
    detect_string = f"--{field_name}."
    exclude_strings = (f"--{field_name}.{draccus.CHOICE_TYPE_KEY}=", f"--{field_name}.{PATH_KEY}=")
    for arg in args:
        if arg.startswith(detect_string) and not arg.startswith(exclude_strings):
            denested_arg = f"--{arg.removeprefix(detect_string)}"
            attr_level_args.append(denested_arg)

    return attr_level_args


def parse_arg(arg_name: str, args: Sequence[str] | None = None) -> str | None:
    if args is None:
        args = sys.argv[1:]
    prefix = f"--{arg_name}="
    for arg in args:
        if arg.startswith(prefix):
            return arg[len(prefix) :]
    return None


def get_path_arg(field_name: str, args: Sequence[str] | None = None) -> str | None:
    return parse_arg(f"{field_name}.{PATH_KEY}", args)


def get_type_arg(field_name: str, args: Sequence[str] | None = None) -> str | None:
    return parse_arg(f"{field_name}.{draccus.CHOICE_TYPE_KEY}", args)


def filter_arg(field_to_filter: str, args: Sequence[str] | None = None) -> list[str]:
    return [arg for arg in args if not arg.startswith(f"--{field_to_filter}=")]


def filter_path_args(fields_to_filter: str | list[str], args: Sequence[str] | None = None) -> list[str]:
    """
    Filters command-line arguments related to fields with specific path arguments.

    Args:
        fields_to_filter (str | list[str]): A single str or a list of str whose arguments need to be filtered.
        args (Sequence[str] | None): The sequence of command-line arguments to be filtered.
            Defaults to None.

    Returns:
        list[str]: A filtered list of arguments, with arguments related to the specified
        fields removed.

    Raises:
        ArgumentError: If both a path argument (e.g., `--field_name.path`) and a type
            argument (e.g., `--field_name.type`) are specified for the same field.
    """
    if isinstance(fields_to_filter, str):
        fields_to_filter = [fields_to_filter]

    filtered_args = args
    for field in fields_to_filter:
        if get_path_arg(field, args):
            if get_type_arg(field, args):
                raise ArgumentError(
                    argument=None,
                    message=f"Cannot specify both --{field}.{PATH_KEY} and --{field}.{draccus.CHOICE_TYPE_KEY}",
                )
            filtered_args = [arg for arg in filtered_args if not arg.startswith(f"--{field}.")]

    return filtered_args


def wrap(config_path: Path | None = None):
    """
    HACK: Similar to draccus.wrap but does two additional things:
        - Will remove '.path' arguments from CLI in order to process them later on.
        - If a 'config_path' is passed and the main config class has a 'from_pretrained' method, will
          initialize it from there to allow to fetch configs from the hub directly
    """

    def wrapper_outer(fn):
        @wraps(fn)
        def wrapper_inner(*args, **kwargs):
            argspec = inspect.getfullargspec(fn)
            argtype = argspec.annotations[argspec.args[0]]
            if len(args) > 0 and type(args[0]) is argtype:
                cfg = args[0]
                args = args[1:]
            else:
                cli_args = sys.argv[1:]
                config_path_cli = parse_arg("config_path", cli_args)
                if has_method(argtype, "__get_path_fields__"):
                    path_fields = argtype.__get_path_fields__()
                    cli_args = filter_path_args(path_fields, cli_args)
                if has_method(argtype, "from_pretrained") and config_path_cli:
                    cli_args = filter_arg("config_path", cli_args)
                    cfg = argtype.from_pretrained(config_path_cli, cli_args=cli_args)
                else:
                    cfg = draccus.parse(config_class=argtype, config_path=config_path, args=cli_args)
            response = fn(cfg, *args, **kwargs)
            return response

        return wrapper_inner

    return wrapper_outer


import platform
import time


def busy_wait(seconds):
    if platform.system() == "Darwin":
        # On Mac, `time.sleep` is not accurate and we need to use this while loop trick,
        # but it consumes CPU cycles.
        # TODO(rcadene): find an alternative: from python 11, time.sleep is precise
        end_time = time.perf_counter() + seconds
        while time.perf_counter() < end_time:
            pass
    else:
        # On Linux time.sleep is accurate
        if seconds > 0:
            time.sleep(seconds)


def safe_disconnect(func):
    # TODO(aliberts): Allow to pass custom exceptions
    # (e.g. ThreadServiceExit, KeyboardInterrupt, SystemExit, UnpluggedError, DynamixelCommError)
    def wrapper(robot, *args, **kwargs):
        try:
            return func(robot, *args, **kwargs)
        except Exception as e:
            if robot.is_connected:
                robot.disconnect()
            raise e

    return wrapper


class RobotDeviceNotConnectedError(Exception):
    """Exception raised when the robot device is not connected."""

    def __init__(
        self, message="This robot device is not connected. Try calling `robot_device.connect()` first."
    ):
        self.message = message
        super().__init__(self.message)


class RobotDeviceAlreadyConnectedError(Exception):
    """Exception raised when the robot device is already connected."""

    def __init__(
        self,
        message="This robot device is already connected. Try not calling `robot_device.connect()` twice.",
    ):
        self.message = message
        super().__init__(self.message)



"""Contains logic to instantiate a robot, read information from its motors and cameras,
and send orders to its motors.
"""
# TODO(rcadene, aliberts): reorganize the codebase into one file per robot, with the associated
# calibration procedure, to make it easy for people to add their own robot.

import json
import logging
import time
import warnings
from pathlib import Path

import numpy as np
import torch

from lerobot.common.robot_devices.cameras.utils import make_cameras_from_configs
from lerobot.common.robot_devices.motors.utils import MotorsBus, make_motors_buses_from_configs
from lerobot.common.robot_devices.robots.configs import ManipulatorRobotConfig
from lerobot.common.robot_devices.robots.utils import get_arm_id
from lerobot.common.robot_devices.utils import RobotDeviceAlreadyConnectedError, RobotDeviceNotConnectedError


def ensure_safe_goal_position(
    goal_pos: torch.Tensor, present_pos: torch.Tensor, max_relative_target: float | list[float]
):
    # Cap relative action target magnitude for safety.
    diff = goal_pos - present_pos
    max_relative_target = torch.tensor(max_relative_target)
    safe_diff = torch.minimum(diff, max_relative_target)
    safe_diff = torch.maximum(safe_diff, -max_relative_target)
    safe_goal_pos = present_pos + safe_diff

    if not torch.allclose(goal_pos, safe_goal_pos):
        logging.warning(
            "Relative goal position magnitude had to be clamped to be safe.\n"
            f"  requested relative goal position target: {diff}\n"
            f"    clamped relative goal position target: {safe_diff}"
        )

    return safe_goal_pos


class ManipulatorRobot:
    # TODO(rcadene): Implement force feedback
    """This class allows to control any manipulator robot of various number of motors.

    Non exaustive list of robots:
    - [Koch v1.0](https://github.com/AlexanderKoch-Koch/low_cost_robot), with and without the wrist-to-elbow expansion, developed
    by Alexander Koch from [Tau Robotics](https://tau-robotics.com)
    - [Koch v1.1](https://github.com/jess-moss/koch-v1-1) developed by Jess Moss
    - [Aloha](https://www.trossenrobotics.com/aloha-kits) developed by Trossen Robotics

    Example of instantiation, a pre-defined robot config is required:
    ```python
    robot = ManipulatorRobot(KochRobotConfig())
    ```

    Example of overwritting motors during instantiation:
    ```python
    # Defines how to communicate with the motors of the leader and follower arms
    leader_arms = {
        "main": DynamixelMotorsBusConfig(
            port="/dev/tty.usbmodem575E0031751",
            motors={
                # name: (index, model)
                "shoulder_pan": (1, "xl330-m077"),
                "shoulder_lift": (2, "xl330-m077"),
                "elbow_flex": (3, "xl330-m077"),
                "wrist_flex": (4, "xl330-m077"),
                "wrist_roll": (5, "xl330-m077"),
                "gripper": (6, "xl330-m077"),
            },
        ),
    }
    follower_arms = {
        "main": DynamixelMotorsBusConfig(
            port="/dev/tty.usbmodem575E0032081",
            motors={
                # name: (index, model)
                "shoulder_pan": (1, "xl430-w250"),
                "shoulder_lift": (2, "xl430-w250"),
                "elbow_flex": (3, "xl330-m288"),
                "wrist_flex": (4, "xl330-m288"),
                "wrist_roll": (5, "xl330-m288"),
                "gripper": (6, "xl330-m288"),
            },
        ),
    }
    robot_config = KochRobotConfig(leader_arms=leader_arms, follower_arms=follower_arms)
    robot = ManipulatorRobot(robot_config)
    ```

    Example of overwritting cameras during instantiation:
    ```python
    # Defines how to communicate with 2 cameras connected to the computer.
    # Here, the webcam of the laptop and the phone (connected in USB to the laptop)
    # can be reached respectively using the camera indices 0 and 1. These indices can be
    # arbitrary. See the documentation of `OpenCVCamera` to find your own camera indices.
    cameras = {
        "laptop": OpenCVCamera(camera_index=0, fps=30, width=640, height=480),
        "phone": OpenCVCamera(camera_index=1, fps=30, width=640, height=480),
    }
    robot = ManipulatorRobot(KochRobotConfig(cameras=cameras))
    ```

    Once the robot is instantiated, connect motors buses and cameras if any (Required):
    ```python
    robot.connect()
    ```

    Example of highest frequency teleoperation, which doesn't require cameras:
    ```python
    while True:
        robot.teleop_step()
    ```

    Example of highest frequency data collection from motors and cameras (if any):
    ```python
    while True:
        observation, action = robot.teleop_step(record_data=True)
    ```

    Example of controlling the robot with a policy:
    ```python
    while True:
        # Uses the follower arms and cameras to capture an observation
        observation = robot.capture_observation()

        # Assumes a policy has been instantiated
        with torch.inference_mode():
            action = policy.select_action(observation)

        # Orders the robot to move
        robot.send_action(action)
    ```

    Example of disconnecting which is not mandatory since we disconnect when the object is deleted:
    ```python
    robot.disconnect()
    ```
    """

    def __init__(
        self,
        config: ManipulatorRobotConfig,
    ):
        self.config = config
        self.robot_type = self.config.type
        self.calibration_dir = Path(self.config.calibration_dir)
        self.leader_arms = make_motors_buses_from_configs(self.config.leader_arms)
        self.follower_arms = make_motors_buses_from_configs(self.config.follower_arms)
        self.cameras = make_cameras_from_configs(self.config.cameras)
        self.is_connected = False
        self.logs = {}

    def get_motor_names(self, arm: dict[str, MotorsBus]) -> list:
        return [f"{arm}_{motor}" for arm, bus in arm.items() for motor in bus.motors]

    @property
    def camera_features(self) -> dict:
        cam_ft = {}
        for cam_key, cam in self.cameras.items():
            key = f"observation.images.{cam_key}"
            cam_ft[key] = {
                "shape": (cam.height, cam.width, cam.channels),
                "names": ["height", "width", "channels"],
                "info": None,
            }
        return cam_ft

    @property
    def motor_features(self) -> dict:
        action_names = self.get_motor_names(self.leader_arms)
        state_names = self.get_motor_names(self.leader_arms)
        return {
            "action": {
                "dtype": "float32",
                "shape": (len(action_names),),
                "names": action_names,
            },
            "observation.state": {
                "dtype": "float32",
                "shape": (len(state_names),),
                "names": state_names,
            },
        }

    @property
    def features(self):
        return {**self.motor_features, **self.camera_features}

    @property
    def has_camera(self):
        return len(self.cameras) > 0

    @property
    def num_cameras(self):
        return len(self.cameras)

    @property
    def available_arms(self):
        available_arms = []
        for name in self.follower_arms:
            arm_id = get_arm_id(name, "follower")
            available_arms.append(arm_id)
        for name in self.leader_arms:
            arm_id = get_arm_id(name, "leader")
            available_arms.append(arm_id)
        return available_arms

    def connect(self):
        if self.is_connected:
            raise RobotDeviceAlreadyConnectedError(
                "ManipulatorRobot is already connected. Do not run `robot.connect()` twice."
            )

        if not self.leader_arms and not self.follower_arms and not self.cameras:
            raise ValueError(
                "ManipulatorRobot doesn't have any device to connect. See example of usage in docstring of the class."
            )

        # Connect the arms
        for name in self.follower_arms:
            print(f"Connecting {name} follower arm.")
            self.follower_arms[name].connect()
        for name in self.leader_arms:
            print(f"Connecting {name} leader arm.")
            self.leader_arms[name].connect()

        if self.robot_type in ["koch", "koch_bimanual", "aloha"]:
            from lerobot.common.robot_devices.motors.dynamixel import TorqueMode
        elif self.robot_type in ["so100", "moss"]:
            from lerobot.common.robot_devices.motors.feetech import TorqueMode

        # We assume that at connection time, arms are in a rest position, and torque can
        # be safely disabled to run calibration and/or set robot preset configurations.
        for name in self.follower_arms:
            self.follower_arms[name].write("Torque_Enable", TorqueMode.DISABLED.value)
        for name in self.leader_arms:
            self.leader_arms[name].write("Torque_Enable", TorqueMode.DISABLED.value)

        self.activate_calibration()

        # Set robot preset (e.g. torque in leader gripper for Koch v1.1)
        if self.robot_type in ["koch", "koch_bimanual"]:
            self.set_koch_robot_preset()
        elif self.robot_type == "aloha":
            self.set_aloha_robot_preset()
        elif self.robot_type in ["so100", "moss"]:
            self.set_so100_robot_preset()

        # Enable torque on all motors of the follower arms
        for name in self.follower_arms:
            print(f"Activating torque on {name} follower arm.")
            self.follower_arms[name].write("Torque_Enable", 1)

        if self.config.gripper_open_degree is not None:
            if self.robot_type not in ["koch", "koch_bimanual"]:
                raise NotImplementedError(
                    f"{self.robot_type} does not support position AND current control in the handle, which is require to set the gripper open."
                )
            # Set the leader arm in torque mode with the gripper motor set to an angle. This makes it possible
            # to squeeze the gripper and have it spring back to an open position on its own.
            for name in self.leader_arms:
                self.leader_arms[name].write("Torque_Enable", 1, "gripper")
                self.leader_arms[name].write("Goal_Position", self.config.gripper_open_degree, "gripper")

        # Check both arms can be read
        for name in self.follower_arms:
            self.follower_arms[name].read("Present_Position")
        for name in self.leader_arms:
            self.leader_arms[name].read("Present_Position")

        # Connect the cameras
        for name in self.cameras:
            self.cameras[name].connect()

        self.is_connected = True

    def activate_calibration(self):
        """After calibration all motors function in human interpretable ranges.
        Rotations are expressed in degrees in nominal range of [-180, 180],
        and linear motions (like gripper of Aloha) in nominal range of [0, 100].
        """

        def load_or_run_calibration_(name, arm, arm_type):
            arm_id = get_arm_id(name, arm_type)
            arm_calib_path = self.calibration_dir / f"{arm_id}.json"

            if arm_calib_path.exists():
                with open(arm_calib_path) as f:
                    calibration = json.load(f)
            else:
                # TODO(rcadene): display a warning in __init__ if calibration file not available
                print(f"Missing calibration file '{arm_calib_path}'")

                if self.robot_type in ["koch", "koch_bimanual", "aloha"]:
                    from lerobot.common.robot_devices.robots.dynamixel_calibration import run_arm_calibration

                    calibration = run_arm_calibration(arm, self.robot_type, name, arm_type)

                elif self.robot_type in ["so100", "moss"]:
                    from lerobot.common.robot_devices.robots.feetech_calibration import (
                        run_arm_manual_calibration,
                    )

                    calibration = run_arm_manual_calibration(arm, self.robot_type, name, arm_type)

                print(f"Calibration is done! Saving calibration file '{arm_calib_path}'")
                arm_calib_path.parent.mkdir(parents=True, exist_ok=True)
                with open(arm_calib_path, "w") as f:
                    json.dump(calibration, f)

            return calibration

        for name, arm in self.follower_arms.items():
            calibration = load_or_run_calibration_(name, arm, "follower")
            arm.set_calibration(calibration)
        for name, arm in self.leader_arms.items():
            calibration = load_or_run_calibration_(name, arm, "leader")
            arm.set_calibration(calibration)

    def set_koch_robot_preset(self):
        def set_operating_mode_(arm):
            from lerobot.common.robot_devices.motors.dynamixel import TorqueMode

            if (arm.read("Torque_Enable") != TorqueMode.DISABLED.value).any():
                raise ValueError("To run set robot preset, the torque must be disabled on all motors.")

            # Use 'extended position mode' for all motors except gripper, because in joint mode the servos can't
            # rotate more than 360 degrees (from 0 to 4095) And some mistake can happen while assembling the arm,
            # you could end up with a servo with a position 0 or 4095 at a crucial point See [
            # https://emanual.robotis.com/docs/en/dxl/x/x_series/#operating-mode11]
            all_motors_except_gripper = [name for name in arm.motor_names if name != "gripper"]
            if len(all_motors_except_gripper) > 0:
                # 4 corresponds to Extended Position on Koch motors
                arm.write("Operating_Mode", 4, all_motors_except_gripper)

            # Use 'position control current based' for gripper to be limited by the limit of the current.
            # For the follower gripper, it means it can grasp an object without forcing too much even tho,
            # it's goal position is a complete grasp (both gripper fingers are ordered to join and reach a touch).
            # For the leader gripper, it means we can use it as a physical trigger, since we can force with our finger
            # to make it move, and it will move back to its original target position when we release the force.
            # 5 corresponds to Current Controlled Position on Koch gripper motors "xl330-m077, xl330-m288"
            arm.write("Operating_Mode", 5, "gripper")

        for name in self.follower_arms:
            set_operating_mode_(self.follower_arms[name])

            # Set better PID values to close the gap between recorded states and actions
            # TODO(rcadene): Implement an automatic procedure to set optimial PID values for each motor
            self.follower_arms[name].write("Position_P_Gain", 1500, "elbow_flex")
            self.follower_arms[name].write("Position_I_Gain", 0, "elbow_flex")
            self.follower_arms[name].write("Position_D_Gain", 600, "elbow_flex")

        if self.config.gripper_open_degree is not None:
            for name in self.leader_arms:
                set_operating_mode_(self.leader_arms[name])

                # Enable torque on the gripper of the leader arms, and move it to 45 degrees,
                # so that we can use it as a trigger to close the gripper of the follower arms.
                self.leader_arms[name].write("Torque_Enable", 1, "gripper")
                self.leader_arms[name].write("Goal_Position", self.config.gripper_open_degree, "gripper")

    def set_aloha_robot_preset(self):
        def set_shadow_(arm):
            # Set secondary/shadow ID for shoulder and elbow. These joints have two motors.
            # As a result, if only one of them is required to move to a certain position,
            # the other will follow. This is to avoid breaking the motors.
            if "shoulder_shadow" in arm.motor_names:
                shoulder_idx = arm.read("ID", "shoulder")
                arm.write("Secondary_ID", shoulder_idx, "shoulder_shadow")

            if "elbow_shadow" in arm.motor_names:
                elbow_idx = arm.read("ID", "elbow")
                arm.write("Secondary_ID", elbow_idx, "elbow_shadow")

        for name in self.follower_arms:
            set_shadow_(self.follower_arms[name])

        for name in self.leader_arms:
            set_shadow_(self.leader_arms[name])

        for name in self.follower_arms:
            # Set a velocity limit of 131 as advised by Trossen Robotics
            self.follower_arms[name].write("Velocity_Limit", 131)

            # Use 'extended position mode' for all motors except gripper, because in joint mode the servos can't
            # rotate more than 360 degrees (from 0 to 4095) And some mistake can happen while assembling the arm,
            # you could end up with a servo with a position 0 or 4095 at a crucial point See [
            # https://emanual.robotis.com/docs/en/dxl/x/x_series/#operating-mode11]
            all_motors_except_gripper = [
                name for name in self.follower_arms[name].motor_names if name != "gripper"
            ]
            if len(all_motors_except_gripper) > 0:
                # 4 corresponds to Extended Position on Aloha motors
                self.follower_arms[name].write("Operating_Mode", 4, all_motors_except_gripper)

            # Use 'position control current based' for follower gripper to be limited by the limit of the current.
            # It can grasp an object without forcing too much even tho,
            # it's goal position is a complete grasp (both gripper fingers are ordered to join and reach a touch).
            # 5 corresponds to Current Controlled Position on Aloha gripper follower "xm430-w350"
            self.follower_arms[name].write("Operating_Mode", 5, "gripper")

            # Note: We can't enable torque on the leader gripper since "xc430-w150" doesn't have
            # a Current Controlled Position mode.

        if self.config.gripper_open_degree is not None:
            warnings.warn(
                f"`gripper_open_degree` is set to {self.config.gripper_open_degree}, but None is expected for Aloha instead",
                stacklevel=1,
            )

    def set_so100_robot_preset(self):
        for name in self.follower_arms:
            # Mode=0 for Position Control
            self.follower_arms[name].write("Mode", 0)
            # Set P_Coefficient to lower value to avoid shakiness (Default is 32)
            self.follower_arms[name].write("P_Coefficient", 16)
            # Set I_Coefficient and D_Coefficient to default value 0 and 32
            self.follower_arms[name].write("I_Coefficient", 0)
            self.follower_arms[name].write("D_Coefficient", 32)
            # Close the write lock so that Maximum_Acceleration gets written to EPROM address,
            # which is mandatory for Maximum_Acceleration to take effect after rebooting.
            self.follower_arms[name].write("Lock", 0)
            # Set Maximum_Acceleration to 254 to speedup acceleration and deceleration of
            # the motors. Note: this configuration is not in the official STS3215 Memory Table
            self.follower_arms[name].write("Maximum_Acceleration", 254)
            self.follower_arms[name].write("Acceleration", 254)

    def teleop_step(
        self, record_data=False
    ) -> None | tuple[dict[str, torch.Tensor], dict[str, torch.Tensor]]:
        if not self.is_connected:
            raise RobotDeviceNotConnectedError(
                "ManipulatorRobot is not connected. You need to run `robot.connect()`."
            )

        # Prepare to assign the position of the leader to the follower
        leader_pos = {}
        for name in self.leader_arms:
            before_lread_t = time.perf_counter()
            leader_pos[name] = self.leader_arms[name].read("Present_Position")
            leader_pos[name] = torch.from_numpy(leader_pos[name])
            self.logs[f"read_leader_{name}_pos_dt_s"] = time.perf_counter() - before_lread_t

        # Send goal position to the follower
        follower_goal_pos = {}
        for name in self.follower_arms:
            before_fwrite_t = time.perf_counter()
            goal_pos = leader_pos[name]

            # Cap goal position when too far away from present position.
            # Slower fps expected due to reading from the follower.
            if self.config.max_relative_target is not None:
                present_pos = self.follower_arms[name].read("Present_Position")
                present_pos = torch.from_numpy(present_pos)
                goal_pos = ensure_safe_goal_position(goal_pos, present_pos, self.config.max_relative_target)

            # Used when record_data=True
            follower_goal_pos[name] = goal_pos

            goal_pos = goal_pos.numpy().astype(np.int32)
            self.follower_arms[name].write("Goal_Position", goal_pos)
            self.logs[f"write_follower_{name}_goal_pos_dt_s"] = time.perf_counter() - before_fwrite_t

        # Early exit when recording data is not requested
        if not record_data:
            return

        # TODO(rcadene): Add velocity and other info
        # Read follower position
        follower_pos = {}
        for name in self.follower_arms:
            before_fread_t = time.perf_counter()
            follower_pos[name] = self.follower_arms[name].read("Present_Position")
            follower_pos[name] = torch.from_numpy(follower_pos[name])
            self.logs[f"read_follower_{name}_pos_dt_s"] = time.perf_counter() - before_fread_t

        # Create state by concatenating follower current position
        state = []
        for name in self.follower_arms:
            if name in follower_pos:
                state.append(follower_pos[name])
        state = torch.cat(state)

        # Create action by concatenating follower goal position
        action = []
        for name in self.follower_arms:
            if name in follower_goal_pos:
                action.append(follower_goal_pos[name])
        action = torch.cat(action)

        # Capture images from cameras
        images = {}
        for name in self.cameras:
            before_camread_t = time.perf_counter()
            images[name] = self.cameras[name].async_read()
            images[name] = torch.from_numpy(images[name])
            self.logs[f"read_camera_{name}_dt_s"] = self.cameras[name].logs["delta_timestamp_s"]
            self.logs[f"async_read_camera_{name}_dt_s"] = time.perf_counter() - before_camread_t

        # Populate output dictionnaries
        obs_dict, action_dict = {}, {}
        obs_dict["observation.state"] = state
        action_dict["action"] = action
        for name in self.cameras:
            obs_dict[f"observation.images.{name}"] = images[name]

        return obs_dict, action_dict

    def capture_observation(self):
        """The returned observations do not have a batch dimension."""
        if not self.is_connected:
            raise RobotDeviceNotConnectedError(
                "ManipulatorRobot is not connected. You need to run `robot.connect()`."
            )

        # Read follower position
        follower_pos = {}
        for name in self.follower_arms:
            before_fread_t = time.perf_counter()
            follower_pos[name] = self.follower_arms[name].read("Present_Position")
            follower_pos[name] = torch.from_numpy(follower_pos[name])
            self.logs[f"read_follower_{name}_pos_dt_s"] = time.perf_counter() - before_fread_t

        # Create state by concatenating follower current position
        state = []
        for name in self.follower_arms:
            if name in follower_pos:
                state.append(follower_pos[name])
        state = torch.cat(state)

        # Capture images from cameras
        images = {}
        for name in self.cameras:
            before_camread_t = time.perf_counter()
            images[name] = self.cameras[name].async_read()
            images[name] = torch.from_numpy(images[name])
            self.logs[f"read_camera_{name}_dt_s"] = self.cameras[name].logs["delta_timestamp_s"]
            self.logs[f"async_read_camera_{name}_dt_s"] = time.perf_counter() - before_camread_t

        # Populate output dictionnaries and format to pytorch
        obs_dict = {}
        obs_dict["observation.state"] = state
        for name in self.cameras:
            obs_dict[f"observation.images.{name}"] = images[name]
        return obs_dict

    def send_action(self, action: torch.Tensor) -> torch.Tensor:
        """Command the follower arms to move to a target joint configuration.

        The relative action magnitude may be clipped depending on the configuration parameter
        `max_relative_target`. In this case, the action sent differs from original action.
        Thus, this function always returns the action actually sent.

        Args:
            action: tensor containing the concatenated goal positions for the follower arms.
        """
        if not self.is_connected:
            raise RobotDeviceNotConnectedError(
                "ManipulatorRobot is not connected. You need to run `robot.connect()`."
            )

        from_idx = 0
        to_idx = 0
        action_sent = []
        for name in self.follower_arms:
            # Get goal position of each follower arm by splitting the action vector
            to_idx += len(self.follower_arms[name].motor_names)
            goal_pos = action[from_idx:to_idx]
            from_idx = to_idx

            # Cap goal position when too far away from present position.
            # Slower fps expected due to reading from the follower.
            if self.config.max_relative_target is not None:
                present_pos = self.follower_arms[name].read("Present_Position")
                present_pos = torch.from_numpy(present_pos)
                goal_pos = ensure_safe_goal_position(goal_pos, present_pos, self.config.max_relative_target)

            # Save tensor to concat and return
            action_sent.append(goal_pos)

            # Send goal position to each follower
            goal_pos = goal_pos.numpy().astype(np.int32)
            self.follower_arms[name].write("Goal_Position", goal_pos)

        return torch.cat(action_sent)

    def print_logs(self):
        pass
        # TODO(aliberts): move robot-specific logs logic here

    def disconnect(self):
        if not self.is_connected:
            raise RobotDeviceNotConnectedError(
                "ManipulatorRobot is not connected. You need to run `robot.connect()` before disconnecting."
            )

        for name in self.follower_arms:
            self.follower_arms[name].disconnect()

        for name in self.leader_arms:
            self.leader_arms[name].disconnect()

        for name in self.cameras:
            self.cameras[name].disconnect()

        self.is_connected = False

    def __del__(self):
        if getattr(self, "is_connected", False):
            self.disconnect()
如果项目二给你提供的代码有不完整的，或者你不知道那个函数的具体实现，请直接中断输出，告诉我提供更多信息










